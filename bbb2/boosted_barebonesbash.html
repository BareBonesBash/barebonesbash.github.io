<!DOCTYPE html>
<html>
  <head>
    <title>Boosted Bare Bones Bash</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700);
      @import url(https://fonts.googleapis.com/css?family=Roboto+Slab:300,300i,400,400i,700);
      @import url(https://fonts.googleapis.com/css?family=Raleway:300,300i,400,400i,700);


      /* font/size formatting */
      body {
        font-family: 'Raleway', sans-serif;
        font-weight: 300;
        color: #000000;
      }

      h1 {
        font-family: 'Roboto Slab', sans-serif;
        color: #7570b3;
        font-weight: 400;
        font-size: 40px;
      }

      h2 {
        font-family: 'Roboto Slab', sans-serif;
        font-weight: 400;
        font-size: 30px;
        color: #7570b3;
      }

      h3 {
        font-family: 'Raleway', sans-serif;
        color: #7570b3;
      }

      /* improve font size modifications - https://github.com/yihui/xaringan/wiki/Font-Size */

      .huge { font-size: 160% }
      .large { font-size: 130% }
      .medium { font-size: 90% }
      .small { font-size: 70% }
      .tiny{font-size: 40%}

      /* https://github.com/gnab/remark/issues/305#issuecomment-403309989 */
      blockquote {
        border-left: 0.3em solid #ccc;
        padding: 0 15px;
        font-style: italic;
        color: #777;
        quotes: "\201C""\201D""\2018""\2019";
        font-size: 18px;
      }

      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono'; color: grey;
      }

      /* Two-column layouts */
      .cols {
        display: flex;
      }
      .left-column  { width: 49%; float: left; }
      .right-column { width: 49%; float: right; }

      .left-column-33  { width: 33%; float: left; }
      .right-column-66 { width: 66%; float: right; }

      .left-column-66  { width: 66%; float: left; }
      .right-column-33 { width: 33%; float: right; }

      .right-column ~ p { clear: both; }
      .right-column ~ ul { clear: both; }

      /* use with e.g. <div class=vertical-center"> */
      .vertical-center {
         margin: 0;
         position: absolute;
         top: 50%;
         -ms-transform: translateY(-50%);
         transform: translateY(-50%);
      }


      .vertical-center-with-title {
         margin: 0;
         position: absolute;
         top: 60%;
         -ms-transform: translateY(-50%);
         transform: translateY(-50%);
      }


      /* For progress bar */
      .remark-slide-number {
        position: inherit;
      }

      .remark-slide-number .progress-bar-container {
        position: absolute;
        bottom: 0;
        height: 4px;
        display: block;
        left: 0;
        right: 0;
      }

      .remark-slide-number .progress-bar {
        height: 100%;
        background-color: #6a3d9a;
      }

    /* Header and Footer from
    https://github.com/gnab/remark/issues/501#issuecomment-392961900/
    */

    div.my-header {
      background-color: #7570b3;
      position: fixed;
      top: 0px;
      left: 0px;
      height: 10px;
      width: 100%;
      text-align: left;
    }

    div.my-footer img {
      height: 75px;
      width: 75px;
      bottom: 5px;
      right: 5px;
      position: fixed;
    }

  /* Comment  */
  .remark-slide-content {
    font-size: 20px;

  }


    </style>
  </head>
  <body>
    <textarea id="source" bar>

layout: true
<div class="my-header"></div>
   <div class="my-footer"><img src="../_images/BareBonesBash_Icon.png" /></div>


---

class: center, middle

# .tiny[_Boosted_ Bespoke]
# .large[**Bare Bones Bash**]
## .tiny[Brought By Blissfully Baffled Bioinformaticians]

Thiseas C. Lamnidis

James A. Fellows Yates

Aida Andrades Valtue√±a
<br/>
<br/>
<br/>

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
  <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
</a>
.small[<br />This work is licensed under a <br/> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.]

---

# Who are we?

.small[### Thiseas]
.medium[
- BSc. @ Department of Biology (York)
- MSc. @ Department of Anthropology (Durham)
- Ph.D.(?) @ Department of Archaeogenetics (Jena)
]

.small[
### James]
.medium[
- BSc. @ Department of Archaeology (York)
- MSc. @ Institute for Archaeological Sciences (T√ºbingen)
- Ph.D.(?) @ Department of Archaeogenetics (Jena)
]

.small[### Aida]
.medium[
- BSc. @ Department of Genetics, UAB (Barcelona)
- MSc. @ Institute for Archaeological Sciences (T√ºbingen)
- Ph.D.(?) @ Department of Archaeogenetics (Jena)
]

.right-column-33[
<div class="vertical-center-with-title">
  <img src=".images/bbb_all.svg" width="80%">
</div>
]

???
BOTH

---

# Aims of this session


- Aim:

  - Get more familiar with text modification with bash

--

- Objectives:
  - How to find stuff?
  - What is a while loop?
  - How to write a conditional statement (if/else)
  - Regular expressions (aka "Regex")
  - How to write a simple bash script
  - _Simple_ text modfication with `sed` (i.e. witchcraft)
  - _Advanced_ text modification with `awk` (i.e. necromancy)

--

.left-column[
<p align="center">
  <img title="Source https://giphy.com/gifs/comedy-retro-musical-UjYw9fdCEPwU8" src="https://media.giphy.com/media/UjYw9fdCEPwU8/giphy.gif" width=55% >
</p>
]

--

.right-column[
<p align="center">
  <img title="Source: https://giphy.com/gifs/bethesda-elder-scrolls-online-necromancer-zumog-phoom-hsaHwzGKJucbXRa7B6" src="https://media.giphy.com/media/hsaHwzGKJucbXRa7B6/giphy.gif" width=70% >
</p>
]

---

# Future outcomes

- Make your work more efficient

  - Large scale modifications of files
  - Make your work more reproducible
  - Wizardary (stuff that we can't even imagine...)

<p align="center">
  <img title="Source: https://giphy.com/gifs/t9lPSqrGSc1IOnajTz"
  src="https://media.giphy.com/media/t9lPSqrGSc1IOnajTz/giphy.gif" width=50% >
</p>

--

- Make fewer mistakes

  - Eliminate human error (blame it on the computer!)

--

- Look like a ~~computer nerd~~ really cool

---

class: center, middle

# **RECAP**: Five Commandments of Bare Bones Bash

???
THISEAS
---

class: middle

.left-column[
### 1. Be lazy!
]

.right-column[
- Desire for shortcuts motivates you explore more!
]

???
It's better to spend 1day working on a script that will save you 5min per day for the rest of your PhD, than putting in those 5 minutes!

TAB will be you favourite key by the time we are done here.

---

class: center, middle
.left-column[
### 1. Be lazy!
### 2. ~~Google~~ The Hive-Mind knows everything.
]

.right-column[
- Desire for shortcuts motivates you explore more!

- 99% of the time, someone else has already had the same issue.

]
???
HOW to google programming questions is not as trivial as it sounds. In the final part of today's session we can talk a bit about this.

---

class: center, middle
.left-column[
### 1. Be lazy!
### 2. ~~Google~~ The Hive-Mind knows everything.
### 3. Document everything you do.
]

.right-column[
- Desire for shortcuts motivates you explore more!

- 99% of the time, someone else has already had the same issue.

- Make future you happy
]

---

class: center, middle

.left-column[
### 1. Be lazy!
### 2. ~~Google~~ The Hive-Mind knows everything.
### 3. Document everything you do.
### 4. There will ALWAYS be a typo!
]
.right-column[
- Desire for shortcuts motivates you explore more!

- 99% of the time, someone else has already had the same issue.

- Make future you happy

- Don't get disheartened, even best programmers make mistakes

]

---

class: center, middle

.left-column[
### 1. Be lazy!
### 2. ~~Google~~ The Hive-Mind knows everything.
### 3. Document everything you do.
### 4. There will ALWAYS be a typo!
### 5. Don't be afraid of you freedom!

]

.right-column[
- Desire for shortcuts motivates you explore more!

- 99% of the time, someone else has already had the same issue.

- Make future you happy

- Don't get disheartened, even best programmers make mistakes

- Explore! Try out things!
]

???
In my experience, most of learning in programming happens by failing. Repeatedly!

---

class: center middle

# Preparation!

---

# Materials

- A long-form walkthrough, and these slides, are all freely avaliable avaliable at:
[https://barebonesbash.github.io/](https://barebonesbash.github.io/#/bbb2/README)

Under the 'Boosted' section.

<center>
**INSERT BOOSTED BBB TOC SCREENSHOT HERE**
</center>

---

# Into the hacker-verse

>  ‚ö†Ô∏èThis section is only for when we are giving the presentation in person! Otherwise, log onto your own unix local PC or server and jump [here](#mind-the)

- Connecting to our server
  - In your browser, go to the URL that you got with your login information.
  - Log-in with the user and password we provided you.

---

class: center

<p align="left"><img src=".images/Jupyter1.png" width="100%" ></p>

---

class: center

<p align="left"><img src=".images/Jupyter2.png" width="100%" ></p>

---

class: center

<p align="left"><img src=".images/Jupyter3.png" width="100%" ></p>

---

class: center

<p align="left"><img src=".images/Jupyter4.png" width="100%" ></p>

---

class: center

<p align="left"><img src=".images/Jupyter5.png" width="100%" ></p>

???
What you see here is the "command prompt". username@server:pwd$
me, at the workshop server. ~ means "my HOME directory" (user specific).

---

name: mind-the

class: middle, center

# Always mind the `$` and `>`!

<p align="center">
  <img title="Source: https://giphy.com/gifs/studiosoriginals-gilphabet-3o84U72tKO389H2lI4" src="https://media.giphy.com/media/3o84U72tKO389H2lI4/giphy.gif" width = "54%">
  <img title="Source: https://giphy.com/gifs/animography-animated-typography-font-gzJNFeqcRcqnm" src="https://media.giphy.com/media/gzJNFeqcRcqnm/giphy.gif" width="30%">
</p>

**Tip** When _sharing_ code, don't include the `$` or `>` from your command prompt! makes it harder for others to run!

To write multi-line code in one: replace a newline with a `;`

???
in Bash ALWAYS MIND THE $ Only copy after the $ so you dont paste the command prompt too. $ is also important when dealing with variables, which you will see later today.

---

class: center,middle

# Uhh... what did we do??

## ([Last time](https://barebonesbash.github.io/#/bbb1/README))

<p align="center">
  <img title="Source: https://giphy.com/gifs/sonic-the-hedgehog-PJiqz1RHkdtGE" src="https://media.giphy.com/media/PJiqz1RHkdtGE/giphy.gif" >
</p>

---

# Uhh... what did we do?

- **Make** a directory:

---
# Uhh... what did we do?


- ~~**Make** a directory:~~

- **What** did that do again?

```bash
$ whatis mkdir
## or
$ man mkdir

```

---

# Uhh... what did we do?

- **Make** a directory:

.left-column[
```bash
$ mkdir boosted_barebonesbash
```
]

.right-column[
> **Tip:** You can specify multiple directories in one command!
]

???
Some people in homework had one `mkdir` command for each directory they made, this isn't necessary! You can specify multiple new names after `mkdir` and each one will be created for you.

--

- How to **download** a file?

```bash
$ wget git.io/Boosted-BBB-meta
```
> Tip: If using a mac use 'curl -O' instead!


--

- How to **move** a something e.g. file into a directory?

```bash
$ mv Boosted-BBB-meta  boosted_barebonesbash/Boosted-BBB-meta.tsv
```
> `mv` can both move and rename! It even does these simultaneously!

---

# Uhh... what did we do?

- **Make** a directory:

.left-column[
```bash
$ mkdir boosted_barebonesbash
```
]

.right-column[
> **Tip:** You can specify multiple directories in one command!
]

- How to **download** a file?

```bash
$ wget git.io/Boosted-BBB-meta
```
> Tip: If using a mac use 'curl -O' instead!

- How to **move** a something e.g. file into a directory?

```bash
$ mv Boosted-BBB-meta  boosted_barebonesbash/Boosted-BBB-meta.tsv
```

.left-column[
- Change **into** a directory

```bash
$ cd boosted_barebonesbash

```

]
--
.right-column[
- What's **inside** my directory (+ info)?

```bash
$ ls -l

```

]


---

# Uhh... what did we do?

- What's **inside** a (text) file?

```bash
$ cat Boosted-BBB-meta.tsv
$ head Boosted-BBB-meta.tsv
$ tail Boosted-BBB-meta.tsv
$ less Boosted-BBB-meta.tsv

```

--

- How to **combine** tools?
- How to **search inside** a text file?

```bash
$ cat Boosted-BBB-meta.tsv | grep 'dog' | wc -l

```

--

> Tip: Be _lazy_; No need for `cat`!

```bash
$ grep 'dog' Boosted-BBB-meta.tsv | wc -l

```


???
Remember we want to be lazy and efficient. While it is sometimes more 'readable', you don't need to cat every file into every program. Almost all programs accept a file by default.

The latter means 1) less typing and 2) less computational resources

--

- How do I **edit** a file?

```bash
$ nano data.csv
```
> To exit without saving any changes: ctrl + x




---

# Uhh... what did we do?

- How to assign a **variable**

```bash
$ Variable=Yes
```

--

- How do I **repeat** a command multiple times on a list of things?

```bash
$ for i in Greece Spain Britain; do
>  echo "Does $i have lovely food? $Variable"
> done

```
--
```
Does Greece have lovely food? Yes
Does Spain have lovely food? Yes
Does Britain have lovely food? Yes

```

---

# Preparation


- Download the following file

```bash
$ <whats_the_command?> git.io/Boosted-BBB-images
```

---

# Preparation

- Download the following file

```bash
## use wget to download a file because it's _cooler_
$ wget git.io/Boosted-BBB-images
```
>Tip: write _why_ and _what_ you are doing in a comment with `#`

???

Also: COMMENTING IS LANGUAGE SPECIFIC. In bash you can only use #.

i.e. Nicely written code should be self explanatory as to 'how', but 'why' is more useful.

--

- `unzip` the `.zip` file by **auto-completing the file name with your TAB key!**

```bash
$ unzip Boosted-BBB-images
```

--

.left-column[
> * What is the name of directory you just extracted?

> * What do you see in there?
]

.right-column[
<p align="center">
  <img title="Source: https://giphy.com/gifs/bobs-burgers-fox-bobs-burgers-3og0IRc1sW8yPON3WM" src="https://media.giphy.com/media/3og0IRc1sW8yPON3WM/giphy.gif" width="80%">
</p>
]

---

# Final Tips

.left-column[
<p align="center">
  <img title="https://giphy.com/gifs/UKTVGIFBANK-eMUEeNGdwU7JDZ28g0" src="https://media.giphy.com/media/eMUEeNGdwU7JDZ28g0/giphy.gif" width="80%">
</p>
]

.left-column[

- ALWAYS include a 'target' directory when using `ln -s` (even if just `.`).
  - This is more readable, and less error prone!

- To select all lines _not_ matching a pattern, can use the grep flag `-v` (no need to `diff`!)

- Comments
  - Comment **step by step**!
  - Better: **why** something is done, rather than _what_ it accomplishes.
  - Helps others (such as your baffled bioinformaticians) and **yourself** in two years.

]

???

Based on common issues with 'homeworks' from in-person sessions of BBB

---

class: middle,center

<p align="center">
  <img title="Source: https://giphy.com/gifs/mario-super-64-WZdlab0U3AkSc
" src="https://media.giphy.com/media/WZdlab0U3AkSc/giphy.gif">
</p>

Make sure to `cd` back to `~/boosted_barebonesbash` now!

???

OK! Recap done! LETS'A GO!

---

#Outline

.large[
- Where is my stuff??
- Concept: Datastreams and redirects
- Concept: Quotes matter!
- While loop: to infinity and beyond!
- How to rename stuff
- Concept: Bash expansion
- Concept: Regular expressions
- Conditionals: IF/ELSE
- Modifying files: SED, PASTE, AWK
]

---

# Where is my stuff??

```bash
$ find
```

How can you search for files and directories hidden in layers and layers
(of your very organised üòâ) directories?

<p align="center">
  <img title="https://giphy.com/gifs/download-find-funsubstancea-XSJIE5xMWA9HO
" src="https://media.giphy.com/media/XSJIE5xMWA9HO/giphy.gif">
</p>

---

# Where is my stuff??
```bash
$ find awesome_gif_collection
```
- **First** part of the `find` command: _the place to look from_

  - e.g. `.` to indicate 'here'
--

  - Could also use `~/`
--

  - Could use absolute path e.g. `/home/james/`

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

> **Question** What is the difference between `~/` and `/home/james`?

---

# Where is my stuff??
```bash
$ find awesome_gif_collection/ -name
```
- **First** part of the `find` command: _the place to look from_
  - e.g. `.` to indicate 'here'
  - Could also use `~/`
  - Could use absolute path e.g. `/home/james/`

- **Second** part of the `find` command: _what type of things to look for?_
  - Use `-type` to define the filetype:
     - __f__ile
     - __d__irectory


---

# Where is my stuff??
```bash
$ find awesome_gif_collection/ -name '*GIF*'
```
- **First** part of the `find` command: _the place to look from_
  - e.g. `.` to indicate 'here'
  - Could also use `~/`
  - Could use absolute path e.g. `/home/james/`

- **Second** part of the `find` command: _what type of things to look for?_
  - Use `-type` to define the filetype:
     - __f__ile
     - __d__irectory

- **Third** part of the `find` command: _what to look in_?
  - Use `-name` to say 'look in _names_ of things'

<br/>
<br/>

---

# Where is my stuff??
```bash
$ find awesome_gif_collection/ -name '*GIF*' -type f
```
- **First** part of the `find` command: _the place to look from_
  - e.g. `.` to indicate 'here'
  - Could also use `~/`
  - Could use absolute path e.g. `/home/james/`

- **Second** part of the `find` command: _what type of things to look for?_
  - Use `-type` to define the filetype:
     - __f__ile
     - __d__irectory

- **Third** part of the `find` command: _what to look in_?
  - Use `-name` to say 'look in _names_ of things'

- **Finally** `-name` should be followed by the names that you want to search for
  - Use wildcards (`*`) for maximum laziness!

---
# Where is my stuff??

We are looking for all files with the suffix `GIF`.

Let's first set the suffix we want to a variable, so we can easily change it in the future.

```bash
suffix="GIF"
```
--

We can now call on this variable in our search. Try the following command:

```bash
$ find awesome_gif_collection/ -type f -name '*$suffix'
```
--
**That found no files!!** But `ls` confirms that these files exist!

--

Now look at the command below:

```bash
$ find awesome_gif_collection/ -type f -name "*$suffix*"
```

What has changed here?

Run the second command.

???
This time the command finds the files! What in 'tarnation is going on!?

---

# Where is my stuff??

We are looking for all files with the suffix `GIF`.

Let's first set the suffix we want to a variable, so we can easily change it in the future.

```bash
suffix="GIF"
```

We can now call on this variable in our search. Try the following command:

```bash
$ find awesome_gif_collection/ -type f -name '*$suffix'
```

**That found no files!!** But `ls` confirms that these files exist!


Now look at the command below:
```bash
$ find awesome_gif_collection/ -type f -name "*$suffix*"
```
.left-column-66[What has changed here?

Run the second command.]

.right-column-33[
<p align="center"><img src="https://tenor.com/view/nagato-naruto-shippuden-nagato-kid-nani-apa-gif-12417317.gif" title="Source: https://tenor.com/view/nagato-naruto-shippuden-nagato-kid-nani-apa-gif-12417317.gif" width="50%">
</p>
]



???
This time the command finds the files! What in tarnation is going on!?


---

# Concept: Quotes matter!

In bash, there is a big difference between a single quote `'` and a double quote `"`!

 - The contents of single quotes, are passed on as they are.
 - Inside double quotes, contents are _interpreted_!

???
That means that it will be read just like the rest of the code.

--

.left-column-66[
In some cases the difference doesn't matter:
```bash
$ echo "I like Greek Food"
$ echo 'I like Greek Food'
```
```
I like Greek Food
I like Greek Food
```
]

--
.right-column-33[
      <p align="center"><img src="https://media.giphy.com/media/NSqQkXJjnsVpZQezfg/giphy.gif" title="Source: https://media.giphy.com/media/NSqQkXJjnsVpZQezfg/" width="90%">
      </p>
      <p align="center"><img src="https://media.giphy.com/media/bh4jzePjmd9iE/giphy.gif" title="Source: https://media.giphy.com/media/bh4jzePjmd9iE/" width="90%">
      </p>
]

.left-column-66[
In other cases it makes all the difference:
```bash
$ Arr=Banana
$ echo 'Pirates say $Arr'
$ echo "Minions say $Arr"
```
```
Pirates say $Arr
Minions say Banana
```
]

???
You can already see from the syntax highlighting that $Arr is treated differently in the two quotes.

---

# Cleaning up the filenames

It seems your favourite GIF provider has the habit of adding ugly hashes at the end of all your vacation pictures!

We will need to clean up the filenames before sorting the pictures by category.

--

**We first show an example that uses `cut` and `rev`.**

Any guesses what these commands might do?

  - `rev`:
  - `cut`:

???
Reward to anyone who uses `whatis` or `man`

---

# Cleaning up the filenames

It seems your favourite GIF provider has the habit of adding ugly hashes at the end of all your vacation pictures!

We will need to clean up the filenames before sorting the pictures by category.

#### We will be using `cut` and `rev`.

Any guesses what these commands might do?

  - `rev`: reverses a character string
  - `cut`: cuts a string into multiple pieces

.left-column[
<p align="center">
  <img style="transform: scaleX(-1)" src="https://media.giphy.com/media/mUGRVgAkamLZe/giphy.gif" title="Source: https://giphy.com/gifs/pony-mUGRVgAkamLZe" width="90%">
</p>
]

.right-column[
<p align="center">
  <img style="transform: scaleX(-1)" src="https://media.giphy.com/media/2GdACZsbRnTmo/giphy.gif" title="Source: https://giphy.com/gifs/movie-photoset-2GdACZsbRnTmo" width="83%">
</p>
]

???

Reward to anyone who uses `whatis` or `man`

---

# Cleaning up filenames

Let's try this out!

```bash
echo "aBcDeF 654321" | rev
```
```
123456 FeDcBa
```

--
`cut` needs some arguments.
 - `-d` specifies the field **d**elimiter we are using. Here it is space (`" "`).
 - `-f` specifies which **f**ield we wish to cut out (the second one).

```bash
echo "aBcDeF 654321" | cut -d " " -f 2
```
```
654321
```

---

# Cleaning up filenames

We could use these tools to collage the desired filenames like this:

```bash
$ for file in *GIF; do
>   new_name=$(echo $file | rev | cut -d "_" -f 2-999 | rev)
>   mv $file $new_name
> done
```
**Do not run this code!**

--

**This code is cumbersome to write, read and understand.**
<p align="center"><img src="https://tenor.com/view/what-confused-ugh-blackadder-rowan-atkinson-gif-11050590.gif" title="Source: https://tenor.com/view/what-confused-ugh-blackadder-rowan-atkinson-gif-11050590.gif" width="50%">
</p>


---

# What just happened?

 - `$()` tells bash to run the commands within parentheses and interpret the output as a string, which is then assigned to the variable `new_name`

 We start out with a filepath: TODO: UPDATE FILE NAMES

 ```
 ~/boosted_barebonesbash/awesome_gif_collection/DCIM00001_aaagcSeMwp5.GIF
 ```
--

 - the filename is `rev`ersed:

 ```
 FIG.5pwMeScgaaa_10000MICD/0202_remmuS_serutciP/hsabsenoberab_detsoob/~
 ```
--

 - the string is `cut` at each `_`, and everything after the first delimiter is kept:

 ```
 10000MICD/0202_remmuS_serutciP/hsabsenoberab_detsoob/~
 ```
--

 - the output is `rev`ersed back:

 ```
 ~/boosted_barebonesbash/awesome_gif_collection/DCIM00001
 ```
--

 - the file is then renamed to this new filename


---
# Writing pretty code

It is a good idea to avoide clunky code like what you just saw.

How to make this code simpler?
```bash
$ for file in *GIF; do
>   new_name=$(echo $file | rev | cut -d "_" -f 2-999 | rev)
>   mv $file $new_name
> done
```

--
We can make it shorter and better with **parameter expansion** (the magic).
???
Remember how we were saying a variable is like a box that you can put anything inside? Imagine being sent baking ingredients in the mail, and making a strudel out of the ingredients as you open the package!
--

<p align="center"><img src="https://tenor.com/view/fantastic-beasts-fantastic-beasts-and-where-to-find-them-strudel-magic-food-gif-7865320.gif" title="Source: https://tenor.com/view/fantastic-beasts-fantastic-beasts-and-where-to-find-them-strudel-magic-food-gif-7865320.gif" width="50%">
</p>

---

# The basics

Here's an example variable:
```bash
$ foo="/home/thiseas/folder/subfolder/BBB.is.bae.txt"
```
???
The absolute file path to some imaginary file.

--

To expand a variable use `${}`.
```bash
$ echo ${foo}
```
```
/home/thiseas/folder/subfolder/BBB.is.bae.txt
```
???
This is actually what bash does behind the scenes when we type $Var thus far.
It is a good idea to put all variables in `{}` so thre is never any confusion as to which is the variable name.

--

You can also add a **parameter** to expansions:
```bash
$ echo ${foo#/home/}
$ echo ${foo#*/}
```
```
thiseas/folder/subfolder/BBB.is.bae.txt
home/thiseas/folder/subfolder/BBB.is.bae.txt

```
???
The first command strips the text after the # from the START of the variable.

You can also use wildcards to make more general expansions.

---

# Some parameters for expansion

```bash
$ foo="/home/thiseas/folder/subfolder/BBB.is.bae.txt"
$ echo ${foo}    # No parameters in this expansion
$ echo ${foo#*/} # Removes everything before the first '/'
$ echo ${foo%.*} # What will this do?
```
--
```
/home/thiseas/folder/subfolder/BBB.is.bae.txt
      thiseas/folder/subfolder/BBB.is.bae.txt
/home/thiseas/folder/subfolder/BBB.is.bae
```
???
Bash will look for the provided pattern ONCE and remove it.

There are more `.` and `/` but they are not removed.
--

These expansion can be generalised:
```bash
$ echo ${foo##*/} # Removes everything before any '/'
$ echo ${foo%%.*} # Removes everything after any '.'
```
--
```
BBB.is.bae.txt
/home/thiseas/folder/subfolder/BBB
```
???
When the parameter is given twice, bash will keep searching for the pattern until it can no longer find it.

---
# More parameters for expansion

You can use two `/` to substitute parts of the variable:
```bash
$ foo="/home/thiseas/folder/subfolder/BBB.is.bae.txt"
$ echo ${foo}                    # No parameters
$ echo ${foo/BBB/BareBonesBash}  # Change BBB to BareBonesBash
```
```
/home/thiseas/folder/subfolder/BBB.is.bae.txt
/home/thiseas/folder/subfolder/BareBonesBash.is.bae.txt
```
--

Leaving the second `/` out replaces the pattern with "an empty string".
```bash
$ echo ${foo/BBB}  # Remove BBB
```
???
That is programmer speak for "nothing". i.e. it removes the pattern.
--
```
/home/thiseas/folder/subfolder/.is.bae.txt
```

---
# The last parameter, I swear!

Finally, you can check the length of a variable by using a `#` BEFORE the variable name.
```bash
$ foo="/home/thiseas/folder/subfolder/BBB.is.bae.txt"
$ echo ${#foo}  # The length of the variable contents
```
--
```
45
```
So the filepath in `foo` is 45 characters long!

--

This parameter is more useful when dealing with **bash arrays** (i.e. lists of things).
<p align="center">
  <img src="https://media.giphy.com/media/xUNd9DLukkavmhybAs/giphy.gif
" title="Source: https://media.giphy.com/media/xUNd9DLukkavmhybAs/giphy.gif
" width="40%">
</p>

---
# Writing pretty code
We can now rewrite this code:
```bash
$ for file in *GIF; do
>   new_name=$(echo $file | rev | cut -d "_" -f 2-999 | rev)
>   echo ${new_name}.GFI
>   # mv $file $new_name.GFI
> done
```

To this:
```bash
$ for file in *GIF; do
>   echo ${file%_*}.GFI
>   # mv ${file} ${file%_*}.GFI
> done
```

Try these to see that the result is the same!

Did you notice a difference in runtime?

???
Notice that this time around, I added ".GIF" at the end of the new filenames manually, since out approach removes it.
This code should run considerably faster, even with just 40 filenames!

It is much more efficient since parameter expansion is one command, instead of 4 commands strung together.

--

When you are satisfied that everything works, remove the comments to rename your files.

---

# Almost done!
We now have all the files named similarly, but some things are still a bit off. The file suffix `GIF` is conventionally written in lowercase characters (`gif`).

Let's change all filename suffixes to be in lowercase letters!

--

Can be done with parameter expansion, but we can use **reg**ular **ex**pressions to do without a for loop.

???
Remember, a string is fancy computer lingo for a sequence of characters and/or numbers. i.e. text

--

 - Regex are an important concept. You will find them in most programming languages.

 - Syntax can vary from language to language, but here's how they work in bash.

---

# Concept: Regular expressions
- Strings that define a search pattern
- Used in 'Search' or 'Search/Replace' functions
- You have already used them!

???
Technically, all the wildcards you have used are regex!

---
# Regex Basics
- `.` : match any character
```{bash}
grep '.ear'
```
```
pear
bear
```
---
# Regex Basics
- `.` : match any character
- `[]`: match range of characters within []
```{bash}
grep 'p[iea]r' regex.txt
```
```
pir
per
par
```
---
# Regex Basics
- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
```{bash}
grep 'p[^iea]r' regex.txt
```
```
pur
```
---
# Regex Basics
- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
```{bash}
grep 'be*r' regex.txt
```
```
beer
br
ber
```
---
# Regex Basics
- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: skip character
```{bash}
grep 'be\*r' regex.txt
```
```
be*r
```
---
# Regex Basics
- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: skip character
- `+`: match 1 or more of the preceding items
```{bash}
grep 'be\+r' regex.txt
```
```
beer
ber
```
---
# Regex Basics
- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: skip character
- `+`: match 1 or more of the preceding items
- `?`: match 0 or 1 of the preceding items
```{bash}
grep 'be\?r' regex.txt
```
```
br
ber
```
---
# Regex Basics
- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: skip character
- `+`: match 1 or more of the preceding items
- `?`: match 0 or 1 of the preceding items
- `^`: beginning line
```{bash}
grep '^[rb]\+' regex.txt
```
```
bear
beer
br
ber
be*r
rear
```
---
# Regex Basics
- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: skip character
- `+`: match 1 or more of the preceding items
- `?`: match 0 or 1 of the preceding items
- `^`: beginning line
- `$`: end of the line
```{bash}
grep 'r$' regex.txt
```
```
pear
pier
pir
per
par
pur
bear
beer
br
ber
be*r
rear
```
???
So if we want to match a specific set of characters, that always follow a `.` and precede the end of the line, which regex characters do we need?

---
# `rename`

`rename` lets you apply a regex to the name of files to rename them.

To convert all suffixes in the directory to lowercase characters:
```bash
$ rename 's/\.GIF$/.gif/' *
```

No for loop needed!

The expression given to `rename` has three parts, separated by `/`

 - First, we define we want to **s**ubstitute the regex matches for another string

--

 - Second, we define the regex to query. `\.GIF$`

???
Why do we need the `\` before the `.`?

To interpret the `.` as a literal `.` and not "any character"

--

 - Finally, we specify what we want to substitute matches with. `.gif`

???
The substitute string is NOT a regex, so we do not need to escape the `.`

Optionally you can specify optiong after the final `/`. For e.g. putting a `g` there will lookfor multiple matches in each line instead.

---
# Onwards!

Ok, so we can now use find to see all the new and pretty filepaths:
```bash
$ suffix="gif"
$ find awesome_gif_collection/ -type f -name "*${suffix}"
```
<p align="center">
  <img src="https://media.giphy.com/media/yJFeycRK2DB4c/giphy.gif
" title="Source: https://media.giphy.com/media/yJFeycRK2DB4c/giphy.gif
" width="40%">
</p>
--

We can finally start sorting the pictures into categories!

To do that, we need to keep track of all the file names. We can easily gather this information using a **redirect**!

---
# Concept: Datastreams
Programs can take in and spit out data from different _streams_. By default there are 3 such data streams.

???
Before we talk about redirects, you need to understand datastreams.

--
.left-column[

- `stdin`: the __st__an__d__ard __in__put
- `stdout`: the __st__an__d__ard __out__put
- `stderr`: the __st__an__d__ard __err__or
]
???
stderr is what is usually printed on your screen, while stout is generally what ends up in output files, but it also goes to your screen by default.
--
.right.column[
<p align="center">
  <img src=".images/Datastreams.png" width="50%">
</p>]
???
In the background, each program also broadcasts an `exit code` which tells you if the program encountered errors. You will never see these in the wild, but it's good to know they exist.
--

.left-column[
<br><br><br>___A program is like the human body; One way in, two ways out!___
]
.right-column[<p align="center"><img src="https://media.giphy.com/media/4kg8IIClzvLtC/giphy.gif" title="Source: https://media.giphy.com/media/4kg8IIClzvLtC/" width="40%">
</p>]
???
In this analogy exit codes would be how the person is _feeling_, I suppose.

---
# Pipes revisited
In the first session you learned about piping. Here's how that works!
<br>
<br>
--

<p>
  <img src=".images/Piping.png" width="100%">
</p>
<br>
<br>
The `stdout` of one script becomes the `stdin` of the other.
`stderr` is printed on your screen.

---
# Concept: Redirects

Much like streams in the real world, datastreams can be redirected.

???
This way you can save the stdout of a program (or even the stderr) into a file to save for later.

--

- `stdin` can be redirected with `<`.

???
An arrow pointing TO your program name!

--

- `stdout` can be redirected with `>`.

???
An arrow pointing AWAY your program name!

--

- `stderr` can be redirected with `2>`.

???
Because it is the secondary output stream.

--

It is also possible to combine streams, but we won't get into that here.
<p align="center"><img src="https://media.giphy.com/media/3o72EWUgbRNfLegO1W/giphy.gif" title="Source: https://media.giphy.com/media/3o72EWUgbRNfLegO1W/" width="80%">
</p>

---

# Let's redirect!

We can get a list of all the file names by redirecting the `stdout` of the `find` command.

```bash
$ suffix="gif"
$ find awesome_gif_collection/ -type f -name "*${suffix}" > File_names.txt
```

--

This time, nothing was printed on your screen, because you redirected that output into a file.

You can `cat` the resulting file to see that everything worked.

<p align="center"><img src="https://media.giphy.com/media/JqDeI2yjpSRgdh35oe/giphy.gif" title="Source: https://media.giphy.com/media/JqDeI2yjpSRgdh35oe/" width="35%">
</p>

---

# ENTER BETTER TITLE HERE

Along with your gifs themselves, you also downloaded `Theme_list.txt`, which groups the gifs by their categories.

Have a look in the file!

???
You wanted to minimise the time you spend typing while on hunting for your best gifs, so you didn't type the category name, but codes A B C for each one.

--

Now we want to put together a list that states in which category each gif was is a part of.

???
You have the names of the gifs, and you have the categories of each too.

--

You can use `paste` to paste the two lists together, and save the results!

```bash
$ paste File_names.txt Theme_list.txt > Annotations.txt
```
```
DCIM00001   A
DCIM00002   A
...
DCIM00039   C
DCIM00040   C
```
???
You now have a meta-data sheet for each gif!

---

# Editing text with `sed`

To share these gifs with your internet friends, you need to properly specify the category names.

During your gif hunting, you downloaded XX first, then XX, and finally to XX. Let's add these names in the `Annotations.txt`.

--

You can use `sed`, short for **s**tream **ed**itor, with a regex to edit the contents of a datastream on-the-fly. **TODO**: Replace country with category

```bash
$ sed 's/C/Greece/' Annotations.txt
```

--
.left-column-33[
```
DGreeceIM00001    A
DGreeceIM00002    A
...
DGreeceIM00039    C
DGreeceIM00040    C
```

Uh-oh!]
.right-column-66[
<p align="center"><img src="https://media.giphy.com/media/3ohzdYJK1wAdPWVk88/giphy.gif" title="Source: https://media.giphy.com/media/3ohzdYJK1wAdPWVk88/" width="60%">
</p>]

???
What happened here? How can we fix it?

Pattern matches the first C in a line. Change pattern to `C$` to only match the last character of the line.

---

# Editing text with `sed`

**TODO**: Replace country with category

```bash
$ sed 's/C$/Greece/' Annotations.txt
```
```
DCIM00001   A
DCIM00002   A
...
DCIM00039   Greece
DCIM00040   Greece
```

???
Much better!

--

Use `-e` to provide multiple regular **e**xpressions to `sed`.
```bash
$ sed -e 's/A$/United Kingdom/' -e 's/B$/Spain/' -e 's/C$/Greece/' Annotations.txt
```
???
Check the results for any errors.

--

When you are happy with the results, it is time to save the edits.

`sed` can edit a file **i**n place, with the `-i` option.
```bash
$ sed -i -e 's/A$/United Kingdom/' -e 's/B$/Spain/' -e 's/C$/Greece/' Annotations.txt
```

---

# Housekeeping

Now that you have a good annotation for your images, let's sort them into different directories, one per gif category.

To do this, we will need to introduce a two new concepts:
 - `while` loops
 - `if`/`else` conditionals

--

####From Basic_BBB:

```bash
for file in file1 file2 file3 file4; do
  echo "${file}"
done
```

For loops repeat a set of code for a set of items, by changing the value of a variable in each iteration.

---

# While loop: to infinity and beyond!
 - For loops are finite, they go throw your list and stop
 - A while loop keeps going until the statement is false
```bash
$ while [statment]; do     #means while statement is true do
>   [whatever you want to do]
> done
```
--
An easy example:

.left-column[
```bash
$ n = 3
$ while n > 0; do
>   echo $n
>   n = $n - s1
> done
```
]
.right-column[
```
3
2
1
```
]

???
use while to move files out of the gifs horrible folder mess?

---
# While loop infinite?
Didn't you say while loop are infinite?
.left-column[
```bash
$ n = 3
$ while n < 5; do
>   echo $n
>   n = $n - 1
> done
```
]
.right-column[
Gif of infinite loop
]
--

- Always include a stop

---

# While read line

A common way to use the while loop is:
```bash
$ cat file.txt
```
```
Mmm
Tasty
Gifs
```
--
.left-column[
```bash
$ while read line; do
>   echo ${line}
> done < file.txt
```
```
Mmm
Tasty
Gifs
```
]

???

This approach lets you save the contents of a line in a variable, that you can then use in your scripting.

The input file is given to the loop after `done`, using a **redirect**.

The `read` function will stop once the file has been completely read, which kills the while loop. That's our exit plan!

We will be using this for our first script!

---

# But I have to do this on a daily basis?

Now, we are already being lazy getting the computer to loop through each file.

But we are downloading tasty gifs EVERYDAY? Do we really wanna do it very time?!

<p align="center"><img src="https://media.giphy.com/media/iE4lKpKqwe7QIQCPjG/giphy.gif" title="Source: https://giphy.com/gifs/memecandy-iE4lKpKqwe7QIQCPjG" width="30%">
</p>

The ultimate goal of anyone working on the command line is to make a program which means you type a single command and it does it for you.

We can do this with a _script_.

---

# Your first script!

So let's start writing your first script `sort_gifs.sh`! Open a text editor

```bash
$ nano sort_gifs.sh
```

???

This will open a nano viewer window in your terminal.

--

<p align="center"><img src="https://media.giphy.com/media/26tn33aiTi1jkl6H6/giphy.gif" title="Source: https://media.giphy.com/media/26tn33aiTi1jkl6H6/" width="60%">
</p>


---

# Your first script!

The first thing you almost always need to do with any script is to specify which language the script is using, is with a 'shebang'

<p align="center"><img src="https://media.giphy.com/media/3o6Mbi2vzeke98ApAA/giphy.gif" title="Source: https://giphy.com/gifs/season-14-the-simpsons-14x5-3o6Mbi2vzeke98ApAA
" width="30%">
</p>

This consists of a `#!` to indicate it's a shebang, then a path to a list that *unix stores locations of all programs in.

On the first line of your text editor window, type:

```bash
#! /usr/bin/env bash
```

---

# Your first script!

**TODO** REWRITE THIS SLIDE ONWARDS

First, you want to set the directory for the script, so add this to the file:
<br>
<br>
<br>
```bash
cd ~/boosted_barebonesbash/awesome_gif_collection/
```

---
# Your first script!

Then you want to use a while loop to read the contents of your annotation file.

To test this works as intended, we will simply `echo` the line.

```bash
cd ~/boosted_barebonesbash/awesome_gif_collection/

while read line; do
  echo "${line}"
done < Annotations.txt
```

--

Close `nano` while saving changes:
  1. Initiate exit with `ctrl + x`
  2. You will be prompted to 'Save modified buffer'.
  3. Press `y` on your keyboard to agree
  4. Press Enter


---
# Your first script!

You can run your script like this:
```bash
$ bash sort_pictures.sh
```

You should see the contents of `Annotations.txt` on your screen.

???
We've achieved what `cat` does, but in a more complicated way, but we know our while loop works properly.

Code should always be tested **as it is being written**. Never assume you won't make errors!

--

Now we can open the file again, and continue editing!
```bash
$ nano sort_pictures.sh
```

---
# Your first script!

The text of each line in the file is kept in the `line` variable.

Let's extract the image name and country as two separate variables.

```bash
cd ~/boosted_barebonesbash/awesome_gif_collection/

while read line; do
  image_name=$(echo "${line}" | cut -f1)
  country_taken=$(echo "${line}" | cut -f2)
  echo "${image_name} was taken in ${country_taken}"
done < Annotations.txt
```

--

Once again, time to save changes, and rerun the script to see if we succeeded.
```bash
$ bash sort_pictures.sh
```
???
You should now see the information printed in a nicer format, and the image names and countries of origins are now kept in separate variables.

--

Now it is time for conditionals!

---
# Conditionals (`if`/`else`)

Let you run code depending on specific conditions.

The basic syntax is like this:
```bash
$ if [[ ${my_variable} == "banana" ]]; then
>   echo "The monkey takes the banana and runs away happily."
> else
>   echo "The monkey doesn't want that!"
> fi
```

???
If the code above is run while `my_variable` is set to "banana", then the top code will execute, esle the bottom will.

`then` is similar to `do` in for/while loops.

`fi` (`if` flipped around), is the equivalent of `done` in for/while loops

Notice the double brackets `[[]]`. Single brackets will often fail.

Notice the double equals `==`. In programming this is used to mean "test for equality", rather than variable assignment.

Finally, the spaces between brackets and their contents are necessary.

--

You can have sequential conditions too with `elif`, short for **el**se **if**.
```bash
$ if [[ ${my_variable} == "banana" ]]; then
>   echo "The monkey takes the banana and runs away happily."
> elif [[ ${my_variable} == "mango" ]]; then
>   echo "The monkey takes the mango and eats it while staring at you."
> else
>   echo "The monkey doesn't want that!"
> fi
```

---
# Notes on conditionals

 - `[[` behaves different to `[`. Usually, `[[` is what you want.
 - You can evaluate mathematic equations with `((`

--

```bash
$ if (( 5 - 2 == 3)); then
>   echo "YES"
> fi
```
```
YES
```

---
# Notes on conditionals

 - `[[` behaves different to `[`. Usually, `[[` is what you want.
 - You can evaluate mathematic equations with `((`
 - `!` can be used as a "not".

???
Making a TRUE a FALSE and vice versa.

--

```bash
$ if ! (( 5 - 2 == 3)); then
>   echo "YES"
> else
>   echo "NO"
> fi
```
```
NO
```
???

This works with square brackets as well.

---
# Notes on conditionals

 - `[[` behaves different to `[`. Usually, `[[` is what you want.
 - You can evaluate mathematic equations with `((`
 - `!` can be used as a "not".
 - Some options can be used to check if files exist, or is a variable has been set.

--

```bash
$ if [[ -f Annotations.txt ]]; then
>   echo "File exists!"
> fi
$ if [[ -n ${banana} ]]; then
>   echo "Variable is set!"
> else
>   echo "Varable is NOT set!"
> fi```
```
File exists!
Varable is NOT set!
```

--

Now back to editing the script!

---
# Your first script!

Here's what we had before.
<br>
<br>
<br>
<br>

```bash
cd ~/boosted_barebonesbash/awesome_gif_collection/

while read line; do
  image_name=$(echo "${line}" | cut -f1)
  country_taken=$(echo "${line}" | cut -f2)

  echo "${image_name} was taken in ${country_taken}"
done < Annotations.txt
```

---
# Your first script!

We now want to create a directory for each country, and move the pictures from that country in it.

Let's add some conditionals!

```bash
cd ~/boosted_barebonesbash/awesome_gif_collection/

while read line; do
  image_name=$(echo "${line}" | cut -f1)
  country_taken=$(echo "${line}" | cut -f2)

  ## Make a new directory for each country, if one doesn't exist.
  mkdir -p ${country_name}

  ## If country_name matches one of the three countries, move the image.
  if [[ ${country_name} == "United Kingdom" ]]; then
    mv ${image_name} United\ Kingdom/
  elif [[ ${country_name} == "Spain" ]]; then
    mv ${image_name} Spain/
  elif [[ ${country_name} == "Greece" ]]; then
    mv ${image_name} Greece/
  fi
done < Annotations.txt
```

--
Save changes, and rerun the script.
```bash
$ bash sort_pictures.sh
```

---
# Housekeeping

This time, we didn't have anything printed on the screen.

Let's see if everything moved as we wanted.

```bash
$ find ~/boosted_barebonesbash/awesome_gif_collection/ -type f -name "*jpg"
```

Good! Everything moved into the subfolders!

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
      /*ratio: "16:9", from: https://github.com/gnab/remark/issues/86#issuecomment-36157045*/
      slideNumberFormat: (current, total) => `
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: ${current/total*100}%">
          </div>
        </div>
      `
    });
    </script>
  </body>
</html>
